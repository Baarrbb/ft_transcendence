

input {
  beats {
    port => 5044
  }
}

filter {
	if [service] == "nginx" {
		if [stream] == "stdout" {
			grok {
				match => { "message" => "%{HTTPD_COMBINEDLOG}" }
			}

			mutate { add_field => { "nginx_type" => "access" } }
		}
		else if [stream] == "stderr" {
			mutate { add_field => { "nginx_type" => "error" } }
		}

		date {
			match => ["timestamp", "dd/MMM/yyyy:HH:mm:ss Z"]
			target => "@timestamp"
		}
	}
	else if [service] == "backend" {

		json {
			source => "message"
			target => "parsed_message"
			remove_field => ["message"]
		}

		mutate {
			rename => { "[parsed_message][time]" => "log_timestamp" }
			rename => { "[parsed_message][msg]" => "msg" }
		}

		if [parsed_message][req] {
			mutate {
				add_field => {
					"req_method" => "%{[parsed_message][req][method]}"
					"req_url" => "%{[parsed_message][req][url]}"
					"req_host" => "%{[parsed_message][req][host]}"
					"req_remoteAddress" => "%{[parsed_message][req][remoteAddress]}"
					"req_remotePort" => "%{[parsed_message][req][remotePort]}"
				}
			}
		}

		if [parsed_message][res] {
			mutate {
				add_field => {
					"res_statusCode" => "%{[parsed_message][res][statusCode]}"
				}
			}
		}

		if [parsed_message][err] {
			mutate {
				add_field => {
					"err_type" => "%{[parsed_message][err][type]}"
					"err_message" => "%{[parsed_message][err][message]}"
					"err_stack" => "%{[parsed_message][err][stack]}"
					"err_statusCode" => "%{[parsed_message][err][statusCode]}"
				}
			}
		}

		date {
			match => ["log_timestamp", "UNIX_MS"]
			target => "@timestamp"
		}
	}
}

output {
  elasticsearch {
    # hosts => ["http://elasticsearch:9200"]
    hosts => ["${ELASTIC_HOST}"]
    user => "${ELASTIC_USERNAME}"
    password => "${ELASTIC_PASSWORD}"
	# ssl => true
    # cacert => "/usr/share/logstash/config/certs/ca.crt"
    index => "logs-%{+YYYY.MM.dd}"
  }
  stdout {
    codec => rubydebug
  }
}
